use cometbft_types::types::commit_sig::CommitSigRaw;
use unionlabs::{
    errors::UnknownEnumVariant,
    google::protobuf::timestamp::{Timestamp, TryFromTimestampError},
    primitives::{encoding::HexPrefixed, Bytes, FixedBytesError, H160},
};

/// Custom BlockIDFlag for BeaconKit.
///
/// BlockIdFlag indicates which BlockID the signature is for
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[cfg_attr(feature = "proto", derive(prost::Enumeration))]
#[repr(i32)]
pub enum BlockIdFlag {
    Absent = 1,
    Commit = 2,
    Nil = 3,
    /// Aggregated commit
    /// Voted for the block and contains aggregated signature.
    AggCommit = 4,
    /// Voted for the block.
    AggCommitAbsent = 5,
    /// Voted for nil and contains aggregated signature.
    AggNil = 6,
    /// Voted for nil.
    AggNilAbsent = 7,
}

/// Convenience implementation to provide this functionality without requiring the `"proto"` feature to be enabled, since the `Error` type for the `TryFrom<i32>` impl generated by the `prost::Enumeration` derive is a prost-specific type.
impl BlockIdFlag {
    fn try_from_i32(value: i32) -> Result<Self, UnknownEnumVariant<i32>> {
        match value {
            1 => Ok(Self::Absent),
            2 => Ok(Self::Commit),
            3 => Ok(Self::Nil),
            4 => Ok(Self::AggCommit),
            5 => Ok(Self::AggCommitAbsent),
            6 => Ok(Self::AggNil),
            7 => Ok(Self::AggNilAbsent),
            _ => Err(UnknownEnumVariant(value)),
        }
    }
}

/// Specialized CommitSig structure for BeaconKit.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(
    feature = "serde",
    derive(serde::Serialize, serde::Deserialize),
    serde(try_from = "CommitSigRaw", into = "CommitSigRaw")
)]
#[cfg_attr(feature = "bincode", derive(bincode::Encode, bincode::Decode))]
pub enum CommitSig {
    // standard cometbft commit sig
    Absent,
    Commit {
        validator_address: H160,
        timestamp: Timestamp,
        signature: Bytes,
    },
    Nil {
        validator_address: H160,
        timestamp: Timestamp,
        signature: Bytes,
    },
    // beacon-kit specific commit sig
    AggCommit {
        validator_address: H160,
        signature: Bytes,
    },
    AggCommitAbsent {
        validator_address: H160,
    },
    AggNil {
        validator_address: H160,
        signature: Bytes,
    },
    AggNilAbsent {
        validator_address: H160,
    },
}

impl From<CommitSig> for CommitSigRaw {
    fn from(value: CommitSig) -> Self {
        match value {
            CommitSig::Absent => Self {
                block_id_flag: BlockIdFlag::Absent as i32,
                validator_address: H160::default(),
                timestamp: None,
                signature: None,
            },
            CommitSig::Commit {
                validator_address,
                timestamp,
                signature,
            } => Self {
                block_id_flag: BlockIdFlag::Commit as i32,
                validator_address: validator_address.into_encoding(),
                timestamp: Some(timestamp),
                signature: Some(signature.into_encoding()),
            },
            CommitSig::Nil {
                validator_address,
                timestamp,
                signature,
            } => Self {
                block_id_flag: BlockIdFlag::Nil as i32,
                validator_address: validator_address.into_encoding(),
                timestamp: Some(timestamp),
                signature: Some(signature.into_encoding()),
            },
            CommitSig::AggCommit {
                validator_address,
                signature,
            } => Self {
                block_id_flag: BlockIdFlag::AggCommit as i32,
                validator_address: validator_address.into_encoding(),
                timestamp: None,
                signature: Some(signature.into_encoding()),
            },
            CommitSig::AggCommitAbsent { validator_address } => Self {
                block_id_flag: BlockIdFlag::AggCommitAbsent as i32,
                validator_address: validator_address.into_encoding(),
                timestamp: None,
                signature: None,
            },
            CommitSig::AggNil {
                validator_address,
                signature,
            } => Self {
                block_id_flag: BlockIdFlag::AggNil as i32,
                validator_address: validator_address.into_encoding(),
                timestamp: None,
                signature: Some(signature.into_encoding()),
            },
            CommitSig::AggNilAbsent { validator_address } => Self {
                block_id_flag: BlockIdFlag::AggNilAbsent as i32,
                validator_address: validator_address.into_encoding(),
                timestamp: None,
                signature: None,
            },
        }
    }
}

impl TryFrom<CommitSigRaw> for CommitSig {
    type Error = Error;

    fn try_from(value: CommitSigRaw) -> Result<Self, Self::Error> {
        let block_id_flag = BlockIdFlag::try_from_i32(value.block_id_flag)?;

        match block_id_flag {
            BlockIdFlag::Absent => {
                if value.validator_address != H160::<HexPrefixed>::default() {
                    Err(Error::AbsentWithValidatorAddress)
                } else if value.timestamp.is_some_and(|ts| ts != Timestamp::default()) {
                    Err(Error::AbsentWithTimestamp)
                } else if !value.signature.unwrap_or_default().is_empty() {
                    Err(Error::AbsentWithSignature)
                } else {
                    Ok(Self::Absent)
                }
            }
            BlockIdFlag::Commit => Ok(Self::Commit {
                validator_address: value.validator_address.into_encoding(),
                timestamp: value.timestamp.ok_or(Error::CommitMissingTimestamp)?,
                signature: value
                    .signature
                    .ok_or(Error::CommitMissingSignature)?
                    .into_encoding(),
            }),
            BlockIdFlag::Nil => Ok(Self::Nil {
                validator_address: value.validator_address.into_encoding(),
                timestamp: value.timestamp.ok_or(Error::NilMissingTimestamp)?,
                signature: value
                    .signature
                    .ok_or(Error::NilMissingSignature)?
                    .into_encoding(),
            }),
            BlockIdFlag::AggCommit => Ok(Self::AggCommit {
                validator_address: value.validator_address.into_encoding(),
                signature: value
                    .signature
                    .ok_or(Error::CommitMissingSignature)?
                    .into_encoding(),
            }),
            BlockIdFlag::AggCommitAbsent => {
                if value.timestamp.is_some_and(|ts| ts != Timestamp::default()) {
                    Err(Error::AbsentWithTimestamp)
                } else if !value.signature.unwrap_or_default().is_empty() {
                    Err(Error::AbsentWithSignature)
                } else {
                    Ok(Self::AggCommitAbsent {
                        validator_address: value.validator_address.into_encoding(),
                    })
                }
            }
            BlockIdFlag::AggNil => {
                if value.timestamp.is_some_and(|ts| ts != Timestamp::default()) {
                    Err(Error::AggNilWithTimestamp)
                } else {
                    Ok(Self::AggNil {
                        validator_address: value.validator_address.into_encoding(),
                        signature: value
                            .signature
                            .ok_or(Error::NilMissingSignature)?
                            .into_encoding(),
                    })
                }
            }
            BlockIdFlag::AggNilAbsent => {
                if value.timestamp.is_some_and(|ts| ts != Timestamp::default()) {
                    Err(Error::AggNilWithTimestamp)
                } else if !value.signature.unwrap_or_default().is_empty() {
                    Err(Error::AbsentWithSignature)
                } else {
                    Ok(Self::AggNilAbsent {
                        validator_address: value.validator_address.into_encoding(),
                    })
                }
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, thiserror::Error)]
pub enum Error {
    #[error("invalid validator_address")]
    ValidatorAddress(#[from] FixedBytesError),
    #[error("invalid block_id_flag")]
    BlockIdFlag(#[from] UnknownEnumVariant<i32>),
    #[error("invalid timestamp")]
    Timestamp(#[from] TryFromTimestampError),
    #[error("block id flag was `Unknown`")]
    UnknownBlockIdFlag,
    #[error("an absent commit sig had an address")]
    AbsentWithValidatorAddress,
    #[error("an absent/agg absent commit sig had a timestamp")]
    AbsentWithTimestamp,
    #[error("an absent/agg absent/agg nill absent  commit sig had a signature")]
    AbsentWithSignature,
    #[error("a commit commit sig requires timestamp to be set")]
    CommitMissingTimestamp,
    #[error("a commit commit sig requires signature to be set")]
    CommitMissingSignature,
    #[error("a nil commit sig requires timestamp to be set")]
    NilMissingTimestamp,
    #[error("an agg nil/agg nil absent commit had a timestamp")]
    AggNilWithTimestamp,
    #[error("a nil commit sig requires signature to be set")]
    NilMissingSignature,
}

#[cfg(feature = "proto")]
pub mod proto {
    use cometbft_types::types::commit_sig::CommitSigRaw;

    use crate::CommitSig;

    // COMETBFT <-> CANONICAL

    impl From<CommitSig> for protos::cometbft::types::v1::CommitSig {
        fn from(value: CommitSig) -> Self {
            CommitSigRaw::from(value).into()
        }
    }

    impl TryFrom<protos::cometbft::types::v1::CommitSig> for CommitSig {
        type Error = super::Error;

        fn try_from(value: protos::cometbft::types::v1::CommitSig) -> Result<Self, Self::Error> {
            CommitSigRaw {
                block_id_flag: value.block_id_flag,
                validator_address: value.validator_address.try_into()?,
                timestamp: value.timestamp.map(TryInto::try_into).transpose()?,
                signature: Some(value.signature.into()),
            }
            .try_into()
        }
    }
}

#[cfg(test)]
mod tests {
    use hex_literal::hex;
    use unionlabs::primitives::{encoding::Base64, Bytes};

    use crate::CommitSig;

    #[test]
    fn json_agg_commit() {
        // this is the aggregated signatures commit and can be found in any block
        // https://berachain-beacon-rpc.publicnode.com/commit?height=3805039

        let json = r#"
            {
                "block_id_flag": 4,
                "validator_address": "09C4AB26B20EF50B371EAF4CB006D6D5B72A53B9",
                "timestamp": "0001-01-01T00:00:00Z",
                "signature": "gCCadb8QHnhhHBCvwgsFO4Z36LlA6qF6NmLXgITBddwUmSjxG6s+uuNkQqSWo8CXBR58HCQkjqlFXYk27RRlVf3zbqP6cc94MtJL+XG2jyfaNkmJXgocdHRkp3l/7Yfq"
            }
        "#;

        let sig = serde_json::from_str::<CommitSig>(json).unwrap();

        assert_eq!(
            sig,
            CommitSig::AggCommit {
                validator_address: hex!("09C4AB26B20EF50B371EAF4CB006D6D5B72A53B9").into(),
                signature: "gCCadb8QHnhhHBCvwgsFO4Z36LlA6qF6NmLXgITBddwUmSjxG6s+uuNkQqSWo8CXBR58HCQkjqlFXYk27RRlVf3zbqP6cc94MtJL+XG2jyfaNkmJXgocdHRkp3l/7Yfq".parse::<Bytes<Base64>>().unwrap().into_encoding()
            }
        );
    }

    #[test]
    fn json_agg_commit_absent() {
        // this is the most common commit and can be found in any block
        // https://berachain-beacon-rpc.publicnode.com/commit?height=3784796

        let json = r#"
            {
                "block_id_flag": 5,
                "validator_address": "B08ADE9A00DFC0A0EACB84BF579B6B6C0C32A645",
                "timestamp": "0001-01-01T00:00:00Z",
                "signature": null
            }
        "#;

        let sig = serde_json::from_str::<CommitSig>(json).unwrap();

        assert_eq!(
            sig,
            CommitSig::AggCommitAbsent {
                validator_address: hex!("B08ADE9A00DFC0A0EACB84BF579B6B6C0C32A645").into()
            }
        );
    }

    #[test]
    fn json_agg_nil() {
        // https://berachain-beacon-rpc.publicnode.com/commit?height=3805039

        let json = r#"
            {
                "block_id_flag": 6,
                "validator_address": "76D5AF272836142878B608C2125DCE729190EF5F",
                "timestamp": "0001-01-01T00:00:00Z",
                "signature": "tvEZ7g279H1n9IQ1K7Qj8xNdT7VEj7pl2qzEGZ0R8LRrYiZMZf2p5ZevC12T+/90AWdtOVoLZhv15y2/jMUUfdkQVh0idTiG3QdqCAtRjOXyKNnSQjHHg8paDrzBROZr"
            }
        "#;

        let sig = serde_json::from_str::<CommitSig>(json).unwrap();

        assert_eq!(
            sig,
            CommitSig::AggNil {
                validator_address: hex!("76D5AF272836142878B608C2125DCE729190EF5F").into(),
                signature: "tvEZ7g279H1n9IQ1K7Qj8xNdT7VEj7pl2qzEGZ0R8LRrYiZMZf2p5ZevC12T+/90AWdtOVoLZhv15y2/jMUUfdkQVh0idTiG3QdqCAtRjOXyKNnSQjHHg8paDrzBROZr".parse::<Bytes<Base64>>().unwrap().into_encoding()
            }
        );
    }

    #[test]
    fn json_agg_nil_absent() {
        // https://berachain-beacon-rpc.publicnode.com/commit?height=3784796

        let json = r#"
            {
                "block_id_flag": 7,
                "validator_address": "8F7E52CBD156EDD9317042F67AE7ABD1D64C9E19",
                "timestamp": "0001-01-01T00:00:00Z",
                "signature": null
            }
        "#;

        let sig = serde_json::from_str::<CommitSig>(json).unwrap();

        assert_eq!(
            sig,
            CommitSig::AggNilAbsent {
                validator_address: hex!("8F7E52CBD156EDD9317042F67AE7ABD1D64C9E19").into(),
            }
        );
    }
}
