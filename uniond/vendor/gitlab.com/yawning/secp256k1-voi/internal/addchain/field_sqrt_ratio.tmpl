// Copyright (c) 2023 Yawning Angel
//
// SPDX-License-Identifier: BSD-3-Clause

// Code generated by {{ .Meta.Name }}. DO NOT EDIT.

package field

// c2 = sqrt(-Z) (value from sage)
var feC2 = NewElementFromCanonicalHex("0x31fdf302724013e57ad13fb38f842afeec184f00a74789dd286729c8303c4a59")

// Sqrt sets `fe = Sqrt(a)`, and returns 1 iff the square root exists.
// In all other cases, `fe = 0`, and 0 is returned.
func (fe *Element) Sqrt(a *Element) (*Element, uint64) {
	// This is slightly more complicated than doing `fe^((p+1)/4)`,
	// but this makes implementing h2c a lot easier, and addchain
	// does all the heavy lifting anyway.

	tmp, isSqrt := NewElement().SqrtRatio(a, feOne)
	fe.ConditionalSelect(&feZero, tmp, isSqrt)

	return fe, isSqrt
}

func (z *Element) SqrtRatio(u, v *Element) (*Element, uint64) {
	// From Hashing to Elliptic Curves (RFC 9380)

	// F.2.1.2.  optimized sqrt_ratio for q = 3 mod 4

	// 1. tv1 = v^2
	tv1 := NewElement().Square(v)

	// 2. tv2 = u * v
	tv2 := NewElement().Multiply(u, v)

	// 3. tv1 = tv1 * tv2
	tv1.Multiply(tv1, tv2)

	// 4. y1 = tv1^c1
	y1 := NewElement().pow3mod4(tv1)

	// 5. y1 = y1 * tv2
	y1.Multiply(y1, tv2)

	// 6. y2 = y1 * c2
	y2 := NewElement().Multiply(y1, feC2)

	// 7. tv3 = y1^2
	tv3 := NewElement().Square(y1)

	// 8. tv3 = tv3 * v
	tv3.Multiply(tv3, v)

	// 9. isQR = tv3 == u
	isQuadraticResidue := tv3.Equal(u)

	// 10. y = CMOV(y2, y1, isQR)
	z.ConditionalSelect(y2, y1, isQuadraticResidue)

	// 11. return (isQR, y)

	return z, isQuadraticResidue
}

func (z *Element) pow3mod4(x *Element) *Element {
	// Exponentiation computation is derived from the addition chain:
	//
	{{- range lines (format .Script) }}
	//	{{ . }}
	{{- end }}
	//
	// Operations: {{ .Ops.Doubles }} squares {{ .Ops.Adds }} multiplies
	//
	// Generated by {{ .Meta.Module }} {{ .Meta.ReleaseTag }}.

	// Allocate Temporaries.
	var (
		{{- range .Program.Temporaries }}
		{{ . }} = NewElement()
		{{- end -}}
	)

	{{ range $i := .Program.Instructions }}
	// {{ printf "Step %d: %s = x^%#x" $i.Output.Index $i.Output (index $.Chain $i.Output.Index) }}
	{{- with add $i.Op }}
	{{ $i.Output }}.Multiply({{ .X }}, {{ .Y }})
	{{ end -}}

	{{- with double $i.Op }}
	{{ $i.Output }}.Square({{ .X }})
	{{ end -}}

	{{- with shift $i.Op }}
	{{ $i.Output }}.Pow2k({{ .X }}, {{ .S }})
	{{ end -}}

	{{- end }}
	return z
}