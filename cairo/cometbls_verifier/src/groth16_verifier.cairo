// Generated by Garaga version 1.0.1

use garaga::definitions::G1Point;
use garaga::groth16::Groth16Proof;
use garaga::pairing_check::MPCheckHintBN254;
use super::groth16_verifier_constants::{N_PUBLIC_INPUTS, ic, precomputed_lines, vk};

#[starknet::interface]
pub trait IGroth16VerifierBN254<TContractState> {
    fn verify_groth16_proof_bn254(
        self: @TContractState, full_proof_with_hints: Span<felt252>,
    ) -> Result<Span<u256>, felt252>;
}

#[derive(Drop)]
pub struct CometblsProof {
    pub groth16_proof: Groth16Proof,
    pub proof_commitment: G1Point,
    pub proof_commitment_pok: G1Point,
    pub mpcheck_hint: MPCheckHintBN254,
    pub msm_hint: Span<felt252>,
    pub commitment_mpcheck_hint: MPCheckHintBN254,
}

#[starknet::contract]
mod Groth16VerifierBN254 {
    use core::circuit::u384;
    #[feature("bounded-int-utils")]
    use core::internal::bounded_int::downcast;
    use garaga::definitions::{E12D, G1G2Pair, G1Point, u288};
    use garaga::ec_ops::{G1PointTrait, ec_safe_add};
    use garaga::groth16::{
        Groth16ProofRawTrait, multi_pairing_check_bn254_3P_2F_with_extra_miller_loop_result,
    };
    use garaga::pairing_check::{MillerLoopResultScalingFactor, multi_pairing_check_bn254_2P_2F};
    use garaga::utils::calldata::{_deserialize_E12D_u288, _deserialize_groth16_proof_points};
    use starknet::SyscallResultTrait;
    use crate::groth16_verifier_constants::{
        commitment_precomputed_lines, pedersen_g, pedersen_g_root_sigma_neg,
    };
    use super::{
        CometblsProof, Groth16Proof, MPCheckHintBN254, N_PUBLIC_INPUTS, ic, precomputed_lines, vk,
    };

    const ECIP_OPS_CLASS_HASH: felt252 =
        0x312d1dd5f967eaf6f86965e3fa7acbc9d0fbd979066a17721dd913736af2f5e;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl IGroth16VerifierBN254 of super::IGroth16VerifierBN254<ContractState> {
        fn verify_groth16_proof_bn254(
            self: @ContractState, full_proof_with_hints: Span<felt252>,
        ) -> Result<Span<u256>, felt252> {
            verify_groth16_proof_bn254(full_proof_with_hints)
        }
    }

    pub fn verify_groth16_proof_bn254(
        full_proof_with_hints: Span<felt252>,
    ) -> Result<Span<u256>, felt252> {
        // DO NOT EDIT THIS FUNCTION UNLESS YOU KNOW WHAT YOU ARE DOING.
        // This function returns Result::Ok(public_inputs) if the proof is valid.
        // If the proof is invalid, it returns Result::Err(error).
        // Read the documentation to learn how to generate the full_proof_with_hints array given
        // a proof and a verifying key.
        let fph = deserialize_full_proof_with_hints_bn254(full_proof_with_hints);
        let groth16_proof = fph.groth16_proof;
        let mpcheck_hint = fph.mpcheck_hint;
        let msm_hint = fph.msm_hint;
        let mut commitment_mpcheck_hint = fph.commitment_mpcheck_hint;

        groth16_proof.raw.check_proof_points(0);

        let ic = ic.span();

        let vk_x: G1Point = match ic.len() {
            0 => panic!("Malformed VK"),
            1 => *ic.at(0),
            _ => {
                // Start serialization with the hint array directly to avoid copying it.
                let mut msm_calldata: Array<felt252> = array![];
                // Add the points from VK and public inputs to the proof.
                Serde::serialize(@ic.slice(1, N_PUBLIC_INPUTS), ref msm_calldata);
                Serde::serialize(@groth16_proof.public_inputs, ref msm_calldata);
                // Complete with the curve indentifier (0 for BN254):
                msm_calldata.append(0);
                // Add the hint array.
                for x in msm_hint {
                    msm_calldata.append(*x);
                }

                // Call the multi scalar multiplication endpoint on the Garaga ECIP ops contract
                // to obtain vk_x.
                let mut _vx_x_serialized = starknet::syscalls::library_call_syscall(
                    ECIP_OPS_CLASS_HASH.try_into().unwrap(),
                    selector!("msm_g1"),
                    msm_calldata.span(),
                )
                    .unwrap_syscall();

                ec_safe_add(
                    Serde::<G1Point>::deserialize(ref _vx_x_serialized).unwrap(),
                    ec_safe_add(*ic.at(0), fph.proof_commitment, 0),
                    0,
                )
            },
        };
        // Perform the pairing check.
        let check = multi_pairing_check_bn254_3P_2F_with_extra_miller_loop_result(
            G1G2Pair { p: vk_x, q: vk.gamma_g2 },
            G1G2Pair { p: groth16_proof.raw.c, q: vk.delta_g2 },
            G1G2Pair { p: groth16_proof.raw.a.negate(0), q: groth16_proof.raw.b },
            vk.alpha_beta_miller_loop_result,
            precomputed_lines.span(),
            mpcheck_hint,
        );

        let res = multi_pairing_check_bn254_2P_2F(
            G1G2Pair { p: fph.proof_commitment, q: pedersen_g },
            G1G2Pair { p: fph.proof_commitment_pok, q: pedersen_g_root_sigma_neg },
            commitment_precomputed_lines.span(),
            commitment_mpcheck_hint,
        )?;

        if !res {
            return Result::Err('PAIRING_CHECK_FAILED');
        }

        match check {
            Result::Ok(_) => Result::Ok(groth16_proof.public_inputs),
            Result::Err(error) => Result::Err(error),
        }
    }

    #[inline(always)]
    fn downcast_u288(l0: felt252, l1: felt252, l2: felt252) -> u288 {
        u288 {
            limb0: downcast(l0).unwrap(),
            limb1: downcast(l1).unwrap(),
            limb2: downcast(l2).unwrap(),
        }
    }

    #[inline(always)]
    fn downcast_u384(l0: felt252, l1: felt252, l2: felt252, l3: felt252) -> u384 {
        u384 {
            limb0: downcast(l0).unwrap(),
            limb1: downcast(l1).unwrap(),
            limb2: downcast(l2).unwrap(),
            limb3: downcast(l3).unwrap(),
        }
    }

    #[inline(always)]
    pub fn deserialize_full_proof_with_hints_bn254(mut serialized: Span<felt252>) -> CometblsProof {
        let groth16_proof_raw = _deserialize_groth16_proof_points(ref serialized);

        let n_public_inputs: u32 = (*serialized.pop_front().unwrap()).try_into().unwrap();
        let mut public_inputs = array![];
        for _ in 0..n_public_inputs {
            public_inputs
                .append(
                    u256 {
                        low: (*serialized.pop_front().unwrap()).try_into().unwrap(),
                        high: (*serialized.pop_front().unwrap()).try_into().unwrap(),
                    },
                );
        }

        let groth16_proof = Groth16Proof {
            raw: groth16_proof_raw, public_inputs: public_inputs.span(),
        };

        let [
            poc_x_0,
            poc_x_1,
            poc_x_2,
            poc_x_3,
            poc_y_0,
            poc_y_1,
            poc_y_2,
            poc_y_3,
            pok_x_0,
            pok_x_1,
            pok_x_2,
            pok_x_3,
            pok_y_0,
            pok_y_1,
            pok_y_2,
            pok_y_3,
        ] =
            serialized
            .multi_pop_front::<16>()
            .unwrap()
            .unbox();
        let proof_commitment = G1Point {
            x: downcast_u384(poc_x_0, poc_x_1, poc_x_2, poc_x_3),
            y: downcast_u384(poc_y_0, poc_y_1, poc_y_2, poc_y_3),
        };
        let proof_commitment_pok = G1Point {
            x: downcast_u384(pok_x_0, pok_x_1, pok_x_2, pok_x_3),
            y: downcast_u384(pok_y_0, pok_y_1, pok_y_2, pok_y_3),
        };

        let mpcheck_hint = deserialize_mpcheck_hint_bn254(ref serialized, 190);
        let commitment_mpcheck_hint = deserialize_mpcheck_hint_bn254(ref serialized, 145);

        let msm_hint = serialized;

        return CometblsProof {
            groth16_proof,
            proof_commitment,
            proof_commitment_pok,
            mpcheck_hint,
            commitment_mpcheck_hint,
            msm_hint,
        };
    }

    pub fn deserialize_mpcheck_hint_bn254(
        ref serialized: Span<felt252>, big_q_len: u32,
    ) -> MPCheckHintBN254 {
        let lambda_root = _deserialize_E12D_u288(ref serialized);
        let lambda_root_inverse = _deserialize_E12D_u288(ref serialized);

        let [
            w0_l0,
            w0_l1,
            w0_l2,
            w2_l0,
            w2_l1,
            w2_l2,
            w4_l0,
            w4_l1,
            w4_l2,
            w6_l0,
            w6_l1,
            w6_l2,
            w8_l0,
            w8_l1,
            w8_l2,
            w10_l0,
            w10_l1,
            w10_l2,
        ] =
            (*serialized
            .multi_pop_front::<18>()
            .unwrap())
            .unbox();

        // full_len -= 18;
        // assert(full_len == serialized.len(), 'F');

        let w = MillerLoopResultScalingFactor {
            w0: downcast_u288(w0_l0, w0_l1, w0_l2),
            w2: downcast_u288(w2_l0, w2_l1, w2_l2),
            w4: downcast_u288(w4_l0, w4_l1, w4_l2),
            w6: downcast_u288(w6_l0, w6_l1, w6_l2),
            w8: downcast_u288(w8_l0, w8_l1, w8_l2),
            w10: downcast_u288(w10_l0, w10_l1, w10_l2),
        };
        // usize_assert_eq(mpcheck_hint.Ris.len(), 34);
        // 34 * 12 * 3 = 1224
        let mut ris_slice = serialized.slice(1, 1224);
        // println!("ris_slice.len(): {}", ris_slice.len());

        let end = serialized.len();
        serialized = serialized.slice(1225, end - 1224 - 1);
        // println!("serialized.len(): {}", serialized.len());
        let mut Ris = array![];
        while let Option::Some(ri) = ris_slice.multi_pop_front::<36>() {
            let [
                w0l0,
                w0l1,
                w0l2,
                w1l0,
                w1l1,
                w1l2,
                w2l0,
                w2l1,
                w2l2,
                w3l0,
                w3l1,
                w3l2,
                w4l0,
                w4l1,
                w4l2,
                w5l0,
                w5l1,
                w5l2,
                w6l0,
                w6l1,
                w6l2,
                w7l0,
                w7l1,
                w7l2,
                w8l0,
                w8l1,
                w8l2,
                w9l0,
                w9l1,
                w9l2,
                w10l0,
                w10l1,
                w10l2,
                w11l0,
                w11l1,
                w11l2,
            ] =
                (*ri)
                .unbox();
            Ris
                .append(
                    E12D {
                        w0: downcast_u288(w0l0, w0l1, w0l2),
                        w1: downcast_u288(w1l0, w1l1, w1l2),
                        w2: downcast_u288(w2l0, w2l1, w2l2),
                        w3: downcast_u288(w3l0, w3l1, w3l2),
                        w4: downcast_u288(w4l0, w4l1, w4l2),
                        w5: downcast_u288(w5l0, w5l1, w5l2),
                        w6: downcast_u288(w6l0, w6l1, w6l2),
                        w7: downcast_u288(w7l0, w7l1, w7l2),
                        w8: downcast_u288(w8l0, w8l1, w8l2),
                        w9: downcast_u288(w9l0, w9l1, w9l2),
                        w10: downcast_u288(w10l0, w10l1, w10l2),
                        w11: downcast_u288(w11l0, w11l1, w11l2),
                    },
                )
        }
        // usize_assert_eq(mpcheck_hint.big_Q.len(), 190);
        let mut big_q_slice = serialized.slice(1, big_q_len * 3);
        let end = serialized.len();
        serialized = serialized.slice(big_q_len * 3 + 1, end - big_q_len * 3 - 1);
        let mut big_q = array![];
        while let Option::Some(q) = big_q_slice.multi_pop_front::<3>() {
            let [l0, l1, l2] = (*q).unbox();
            big_q.append(downcast_u288(l0, l1, l2))
        }

        let z = (*serialized.pop_front().unwrap()).try_into().unwrap();

        let mpcheck_hint = MPCheckHintBN254 {
            lambda_root: lambda_root,
            lambda_root_inverse: lambda_root_inverse,
            w: w,
            Ris: Ris.span(),
            big_Q: big_q,
            z: z,
        };
        return mpcheck_hint;
    }
}


#[cfg(test)]
mod tests {
    use snforge_std::fs::{FileTrait, read_txt};
    use snforge_std::{DeclareResultTrait, declare};
    use super::Groth16VerifierBN254::deserialize_full_proof_with_hints_bn254;
    #[test]
    fn test_proof() {
        let file = FileTrait::new("tests/proof_calldata.txt");
        let calldata = read_txt(@file).span();

        deserialize_full_proof_with_hints_bn254(calldata);
    }
}
