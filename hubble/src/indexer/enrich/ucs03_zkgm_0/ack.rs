use alloy_primitives::U256;
use alloy_sol_types::{private::Bytes, sol, SolType};
use anyhow::{Context, Result};
use serde::{
    ser::{Error as SerdeError, SerializeStruct},
    Serialize, Serializer,
};
use serde_json::Value;

use crate::indexer::enrich::ucs03_zkgm_0::packet::{
    Batch, Forward, FungibleAssetOrder, Instruction, Multiplex, Operand, ZkgmPacket,
};

const ACK_FAILURE: U256 = U256::ZERO;

sol! {
    #[derive(Serialize, Debug)]
    struct Ack {
        uint256 tag;
        bytes innerAck;
    }

    struct BatchAck {
        bytes[] acknowledgements;
    }

    #[derive(Serialize, Debug)]
    struct FungibleAssetOrderAck {
        uint256 fillType;
        bytes marketMaker;
    }
}

#[derive(Debug)]
struct InstructionPacketAck {
    instruction: Instruction,
    ack: Ack,
}

impl Serialize for InstructionPacketAck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Create a struct with version, opcode, and operand
        let mut state = serializer.serialize_struct("Ack", 2)?;
        state.serialize_field("tag", &self.ack.tag)?;

        if self.ack.tag != ACK_FAILURE {
            let operand = &self.instruction.decode_operand().map_err(|err| {
                S::Error::custom(format!("error decoding operand (in ack): {err}"))
            })?;

            // Custom serialization for operand based on version and opcode
            let inner_ack = decode_inner_ack(operand, &self.ack.innerAck)
                .map_err(|err| S::Error::custom(format!("error decoding ack (in ack): {err}")))?;
            state.serialize_field("innerAck", &inner_ack)?;
        } else {
            state.skip_field("innerAck")?;
        }

        state.end()
    }
}

#[derive(Debug)]
struct BatchPacketAck {
    instructions: Vec<Instruction>,
    acknowledgements: Vec<Bytes>,
}

impl Serialize for BatchPacketAck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Create a struct with version, opcode, and operand
        let mut state = serializer.serialize_struct("BatchAck", 2)?;

        if self.instructions.len() != self.acknowledgements.len() {
            return Err(S::Error::custom(format!(
                "instructions count {} <> acknowlegements count {}",
                &self.instructions.len(),
                self.acknowledgements.len()
            )));
        }

        let acknowledgements = self
            .instructions
            .iter()
            .zip(&self.acknowledgements)
            .enumerate()
            .map(|(index, (instruction, ack))| {
                decode_inner_ack(
                    &instruction
                        .decode_operand()
                        .context(format!("decoding operand packet {index}"))?,
                    ack,
                )
                .context(format!("decoding ack packet {index}"))
            })
            .collect::<Result<Vec<_>>>()
            .map_err(|err| S::Error::custom(format!("error batch acks: {err}")))?;

        state.serialize_field("acknowledgements", &acknowledgements)?;

        state.end()
    }
}

fn decode_inner_ack(operand: &Operand, ack: &Bytes) -> Result<InnerAck> {
    Ok(match operand {
        Operand::Forward(Forward::V0(forward)) => InnerAck::Forward(InstructionPacketAck {
            instruction: forward.instruction.clone(),
            ack: <Ack>::abi_decode_sequence(ack).context("decoding ForwardAck V0")?,
        }),
        Operand::Multiplex(Multiplex::V0(_)) => InnerAck::Multiplex { data: ack.clone() },
        Operand::Batch(Batch::V0(batch)) => InnerAck::Batch(BatchPacketAck {
            instructions: batch.instructions.clone(),
            acknowledgements: <BatchAck>::abi_decode_sequence(ack)
                .context("decoding BatchAck V0")?
                .acknowledgements,
        }),
        Operand::FungibleAssetOrder(FungibleAssetOrder::V0(_)) => InnerAck::FungibleAssetOrder(
            <FungibleAssetOrderAck>::abi_decode_sequence(ack)
                .context("decoding FungibleAssetOrderAck V0")?,
        ),
        Operand::FungibleAssetOrder(FungibleAssetOrder::V1(_)) => InnerAck::FungibleAssetOrder(
            <FungibleAssetOrderAck>::abi_decode_sequence(ack)
                .context("decoding FungibleAssetOrderAck V1")?,
        ),
        Operand::Unsupported { data: _ } => InnerAck::Unsupported { data: ack.clone() },
    })
}

#[derive(Serialize, Debug)]
#[serde(tag = "_type")]
enum InnerAck {
    Forward(InstructionPacketAck),
    Multiplex { data: Bytes },
    Batch(BatchPacketAck),
    FungibleAssetOrder(FungibleAssetOrderAck),
    Unsupported { data: Bytes },
}

pub fn decode(packet: &[u8], ack: &[u8]) -> Result<Value> {
    let instruction = <ZkgmPacket>::abi_decode_sequence(packet)
        .context("decoding zkgm packet")?
        .instruction;
    let ack = <Ack>::abi_decode_sequence(ack).context("decoding ack packet")?;

    let instruction_ack = InstructionPacketAck { instruction, ack };

    let value = serde_json::to_value(&instruction_ack).context("formatting json")?;

    Ok(value)
}

#[cfg(test)]
mod tests {
    use serde_json::json;

    use super::*;

    #[test]
    fn test_fungible_asset_transfer_ack() {
        let json = decode(&hex::decode("0B00DD4772D3B8EBF5ADD472A720F986C0846C9B9C1C0ED98F1A011DF8486BFC0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002C00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014E6831E169D77A861A0E71326AFA6D80BCC8BC6AA0000000000000000000000000000000000000000000000000000000000000000000000000000000000000014E6831E169D77A861A0E71326AFA6D80BCC8BC6AA0000000000000000000000000000000000000000000000000000000000000000000000000000000000000014779877A7B0D9E8603169DDBD7836E478B462478900000000000000000000000000000000000000000000000000000000000000000000000000000000000000044C494E4B00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F436861696E4C696E6B20546F6B656E00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014D1B482D1B947A96E96C9B76D15DE34F7F70A20A1000000000000000000000000").unwrap(),&hex::decode("0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000B0CAD000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000").unwrap()).unwrap();

        dbg!(serde_json::to_string(&json).unwrap());

        assert_eq!(
            json,
            json!({
              "innerAck": {
                "_type": "FungibleAssetOrder",
                "fillType": "0xb0cad0",
                "marketMaker": "0x"
              },
              "tag": "0x1"
            })
        );
    }

    #[test]
    fn test_batch_ack() {
        let json = decode(&hex::decode("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000560000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000014153919669edc8a5d0c8d1e4507c9ce60435a11770000000000000000000000000000000000000000000000000000000000000000000000000000000000000014153919669edc8a5d0c8d1e4507c9ce60435a11770000000000000000000000000000000000000000000000000000000000000000000000000000000000000014dc7af843e4eb079cd77ace6774bd71d6b8122f07000000000000000000000000000000000000000000000000000000000000000000000000000000000000003a666163746f72792f756e696f6e31327164766d7732326e37326d656d3079736666336e6c796a32633736637579347836306c75612f636c6f776e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000148b4bfb23f4d75feef28b4099c0114e5840d14a4700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000014153919669edc8a5d0c8d1e4507c9ce60435a11770000000000000000000000000000000000000000000000000000000000000000000000000000000000000014271126f4f9b36ce16d9e2ef75691485ddce11db60000000000000000000000000000000000000000000000000000000000000000000000000000000000000004cafebabe00000000000000000000000000000000000000000000000000000000").unwrap(),&hex::decode("00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000b0cad00000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001").unwrap()).unwrap();

        dbg!(serde_json::to_string(&json).unwrap());

        assert_eq!(
            json,
            json!({
              "innerAck": {
                "_type": "Batch",
                "acknowledgements": [
                  {
                    "_type": "FungibleAssetOrder",
                    "fillType": "0xb0cad0",
                    "marketMaker": "0x"
                  },
                  {
                    "_type": "Multiplex",
                    "data": "0x0000000000000000000000000000000000000000000000000000000000000001"
                  }
                ]
              },
              "tag": "0x1"
            })
        );
    }

    #[test]
    fn test_failed_batch_ack() {
        let packet: &[u8] = &hex::decode("21DCD61E3C11DB415E36AA1CD285ED7C37A28501C017CDE58F7A2967545A7E270000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000005E0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002A00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001C000000000000000000000000000000000000000000000000000000000000003E8000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000003E8000000000000000000000000000000000000000000000000000000000000001415EE7C367F4232241028C36E720803100757C6E90000000000000000000000000000000000000000000000000000000000000000000000000000000000000040756E696F6E316777716334776774797A6D747A76676D6B326A6565746C6B343570723063646834387A6D357471716D7464736A6675366A6C357338306337336C0000000000000000000000000000000000000000000000000000000000000014F2865969CF99A28BB77E25494FE12D5180FE0EFD00000000000000000000000000000000000000000000000000000000000000000000000000000000000000046D756E6F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046D756E6F0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001C00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000C00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000001415EE7C367F4232241028C36E720803100757C6E90000000000000000000000000000000000000000000000000000000000000000000000000000000000000040756E696F6E316777716334776774797A6D747A76676D6B326A6565746C6B343570723063646834387A6D357471716D7464736A6675366A6C357338306337336C00000000000000000000000000000000000000000000000000000000000000807B22626F6E64223A7B22616D6F756E74223A7B22616D6F756E74223A2231323334222C2264656E6F6D223A226D756E6F227D2C2273616C74223A22307832316463643631653363313164623431356533366161316364323835656437633337613238353031633031376364653538663761323936373534356137653237227D7D").unwrap();

        let ack: &[u8] = &hex::decode("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000").unwrap();

        let json = decode(packet, ack).unwrap();

        dbg!(serde_json::to_string(&json).unwrap());

        assert_eq!(
            json,
            json!({
              "tag": "0x0"
            })
        );
    }
}
