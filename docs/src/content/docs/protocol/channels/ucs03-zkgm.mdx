---
title: "ucs03-zkgm-1"
sidebar:
  badge:
    text: live
    variant: note
---

import Mermaid from "#/components/Mermaid.astro";

# Overview

`ucs03-zkgm-1` is the most advanced and recommended protocol to use for

- message passing
- transfers (assets and NFTs)
- intents
- storage proofs

It's the most gas-efficient version and suitable for almost all use cases.

## Protocol

There are two main modes for a packet to be transferred using `ucs03-zkgm-1`. The main mode, which always succeeds for any chain,
leverages state lenses to create a recursive connection and a communication channel between two chains.


<Mermaid
  content={`
sequenceDiagram
    critical
        Chain A ->> Union: ClientUpdate
        Union ->> Chain B: ClientUpdate
        Chain A -->> Chain B: Packet
    end
    Chain B ->> Union: ClientUpdate
    Union ->> Chain A: ClientUpdate
    Chain B -->> Chain A: Acknowledgement
`}/>

The packet submission is not routed through any PFM middleware, which avoids re-execution on Union, unlike `ucs01-relay-1`. The core protocol is
significantly more gas efficient over multi-hop-based protocols.

### Open Filling

A groundbreaking protocol improvement on IBC and trust-minimized bridging in general, is that `ucs03-zkgm-1` allows arbitrary filling of orders by any party.

:::tip

Read more on filling and counterparty risk [here](/concepts/filling).

:::

For packet submissions and transfers, the protocol allows a different filler from the Union IBC contracts. In the case of an alternative filler, the assets
are not minted but transferred from the filler's account. This allows a transfer to be filled before chains have been finalized or client updates processed. Instead,
fillers can rely on preconfirmations to reduce the risk of reorgs.

<Mermaid
  content={`
sequenceDiagram
    participant Chain A
    participant Union
    participant Chain B
    critical
        Chain A -->> Chain B: Packet
        Chain A ->> Union: ClientUpdate
        Union ->> Chain B: ClientUpdate
    end
    Chain B ->> Union: ClientUpdate
    Union ->> Chain A: ClientUpdate
    Chain B -->> Chain A: Acknowledgement
`}/>

Theoretically, a filler can submit the transfer to the destination side before the transaction is included on the source, given that they protect themselves against double-spend attacks.

The `Acknowledgement`, which may contain arbitrary payloads, is used to encode information on the filler and repay the filler for the service by unlocking assets from the vault.

Open filling is opt-in for any protocol, allowing for the same optimizations that `ucs03-zkgm-1` leverages to increase transfer speeds.

### Batching

To minimize the cost of packet verification (which is dominated by membership proofs), packets may be batched. This means that at scale, the gas cost of transfers tends to the
erc20 gas cost, which is the theoretical optimum.

:::note

Read more on filling and counterparty risk [here](/concepts/filling).

:::

# V0 Specification

The zkgm protocol abstracts away multiple facets of IBC and Union's assets transfer protocol (uc01).
We employ versioning in this protocol to ensure backward compatibility with future upgrades (not relying on the IBC channel upgrade feature).
It's features include:
- batching
- forward/callback envelopes
- channel multiplexing
- fungible assets transfer
- non-fungible assets transfer

## Packet

A zkgm packet is structured as following: `[salt, path, instruction]`

### Salt

The `salt` is a `bytes32` field used for unique and deterministic packet hashing.

It **MUST** be prefixed with the sender address to avoid collisions between users.

Subsequent packets (yield from the protocol itself after receiving a first packet, such as in the [forwarding](#0x00---forward) case) **MUST** have the inner salt updated in place with `next_packet.salt = keccak256(previous_packet.salt, next_packet.salt)`. This ensures the uniqueness of subsequents packets and still allow counterfactual computation of their hashes.

### Path

The `path` is a `uint256` field used to determine the origin of the packet when forwarding. It consist of the compressed `uint32` channel ids taken by the packet from the source to the destination: `srcChannel0 | dstChannel0 << 32 | srcChannel1 << 64 ...`. The construction limits the number of hops to a maximum of `256/64 = 4`.

Similarly to the `salt`, it **MUST** be updated whenever a packet is forwarded from one chain to another.


The construction

- `syscall_index` is a `uint8` representing the [zkgm system call](#syscalls) to which the `packet` will be routed
- `packet` is a `bytes` representing the syscall specific message

- `version` is a `uint8` representing the protocol version

:::note

The `version` field is embedded in every instruction. One may think that this value is redundant for recursive packets. The reality is that upgrade propagation may take time (optimistic rollups for instance) and having every instruction specifying their version will allow to dispatch from a higher version to a lower one. This is specifically true for packet forwarding (chain **A** running version `X` forwarding to a chain **B** running version `Y`).

:::


## Syscalls

### 0x00 - Forward

The forward syscall is living at index `0x00`.

It's packet structure is: `[channel_id, zkgm_packet]`

Where:
- `channel_id` is the IBC channel the message will be forwarded to
- `zkgm_packet` is the [packet](#packet) to send

:::tip

The `zkgm_packet` is itself a zkgm packet, meaning this structure is recursive.
One can easily wrap a packet `P` in multiple envelopes, transferring `P` from chain `A` to `D` via two channels `x` and `y` would result in: `[ZKGM_V0, [FORWARD_SYSCALL, [x, [ZKGM_V0, [FORWARD_SYSCALL, [y, [ZKGM_V0, P]]]]]]]`

:::

<Mermaid
  content={`
sequenceDiagram
    X ->> zkgm A: send(channel-1, forward(channel-2, packet))
    zkgm A ->> zkgm B: onRecv(channel-1, forward(channel-2, packet))
    zkgm B ->> zkgm B: exec(forward(channel-2, packet))
    zkgm B ->> zkgm C: onRecv(channel-2, packet)
    zkgm C ->> zkgm C: exec(packet)
    zkgm C ->> zkgm C: writeAck(packet, ack)
    zkgm C ->> zkgm B: onAck(packet, ack)
    zkgm B ->>  zkgm B: writeAck(forward(channel-2, packet), ack)
    zkgm B ->>  zkgm A: onAck(forward(channel-2, packet), ack)
`}/>

### 0x01 - Multiplex

The multiplex syscall is living at index `0x01`.

It's packet structure is: `[sender, eureka, contract_address, calldata]`

Where:
- `sender` is a `bytes` representing the sender address
- `eureka` is a `bool` indicating whether the call must be a recursive IBC operation (zkgm operates as the stack by multiplexing it's channel):
  - if `true`, the receiving contract will have an `onRecvPacket` dispatched with the ibc packet being `(sender, calldata)` where the sender is the contract that initially triggered the packet on the zkgm protocol. The called contract must answer similarly to when called by the IBC stack, it **MUST** return a non asynchronous acknowledgement. The acknowledgement will be forwarded back to the `sender` once the multiplex packet itself is acknowledged.
  - if `false`, the receiving contract will have a `onZkgm(sender, calldata)` call dispatched. This message will be fired and forgot, no acknowledgement will be returned to the `sender`.
- `contract_address` is a `bytes` representing the destination contract address, it **MUST** be a valid binary representation of an address on the destination chain
- `calldata` is a `bytes` representing the message to be sent, it **MUST** be a valid binary representation of a contract call on the destination chain.

<Mermaid
  content={`
sequenceDiagram
    X ->> zkgm A: send(channel-1, multiplex(X, is_eureka, Y, M))
    alt IS NOT EUREKA
        zkgm A ->> zkgm B: onRecv(channel-1, multiplex(X, false, Y, M))
        zkgm B ->> Y: onZkgm((X, M))
        zkgm B ->> zkgm A: onAck(multiplex(X, false, Y, M), true)
    end
    alt IS EUREKA
        zkgm A ->> zkgm B: onRecv(channel-1, multiplex(X, true, Y, M))
        zkgm B ->> Y: onRecv((X, M))
        Y ->> zkgm B: writeAck(multiplex(X, true, Y, M), ack)
        zkgm B ->> zkgm A: onAck(multiplex(X, true, Y, M), ack)
        zkgm A ->> X: onAck(multiplex(X, true, Y, M), ack)
    end
`}/>

### 0x02 - Batch

The batch syscall is living at index `0x02`.

It's packet structure is: `[p₀, p₁, …]`

Where the packets are atomically executed in sequence. Their acknowledgements may be written asynchronously if one of them is a [forward envelope](#0x00---forward). Once all acknowledgements has been written, the batch itself is acknowledged in the origin chain.

<Mermaid
  content={`
sequenceDiagram
    X ->> zkgm A: send(channel-1, [p₀, p₁, …])
    zkgm A ->> zkgm B: onRecv(channel-1, [p₀, p₁, …])
    zkgm B ->> zkgm B: exec(p₀)
    zkgm B ->> zkgm B: exec(p₁)
    zkgm B ->> zkgm B: …
    par
        zkgm B ->> zkgm B: writeAck(p₀, ack₀)
    and
        zkgm B ->> zkgm B: writeAck(p₁, ack₁)
    and
        zkgm B ->> zkgm B: …
    end
    zkgm B ->> zkgm A: onAck([ack₀, ack₁, …])
`}/>

:::tip

In combination with forward envelopes or multiplexing, this batching mechanism is very useful to call contract before/after message execution (transfer an asset, swap it then stake the final asset).

:::

### 0x03 - Fungible Assets Transfer

The fungible assets transfer syscall is living at index `0x03`.

It's packet structure is: `[sender, receiver, sent_token_address, sent_amount, ask_token_address, ask_minimum_amount]`

Where:
- `sender` is a `bytes` representing the sender address
- `receiver` is a `bytes` representing the receiver address, it **MUST** be a valid binary representation of an address on the destination chain
- `sent_token_address` is a `bytes` representing the asset that has been sent (escrowed or burnt on the counterparty side)
- `sent_amount` is a `uint256` representing the amount that has been sent
- `ask_token_address` is a `bytes` representing the asset the user is asking against it's sent asset, it **MUST** be a valid binary representation of an asset on the destination chain. In the receiving side
   - An intent filling is possible, with a market maker providing the `ask_amount` and the protocol ensuring that the trade happens correctly (executing the transfer from the market maker to the user for every asset).
   - In the non-intent variant, if the protocol detects that the address matches the protocol wrapped asset, i.e. `wrapped(sent_token_address)`, it fills the order itself by minting the `ask_amount` after asserting that `sent_amount >= ask_amount`.
- `ask_amount` is the minimum amount the user is willing to get for the order to be successfully filled.


<Mermaid
  content={`
sequenceDiagram
    X ->> zkgm A: send(channel-1, assetTransfer(X, …))
    alt wrapped asset protocol filling
        zkgm A ->> zkgm B: onRecv(channel-1, assetTransfer(X, …))
        zkgm B ->> zkgm B: assert(askToken ≡ wrapped(sentToken) ∧ askAmount ≤ sentAmount)
        zkgm B ->> zkgm B: mint(receiver, askToken, askAmount))
        zkgm B ->> zkgm B: writeAck(assetTransfer(X, …), protocolFilledAck)
        zkgm B ->> zkgm A: onAck(assetTransfer(X, …), protocolFilledAck)
    end
    alt intent filling
        Y ->> askToken: allow(zkgm B, askAmount)
        Y ->> zkgm B: onIntentRecv(channel-1, assetTransfer(X, …))
        zkgm B ->> zkgm B: transferFrom(askToken, askAmount, Y, receiver))
        zkgm B ->> zkgm B: writeAck(assetTransfer(X, …), marketMakerFilledAck)
        zkgm B ->> zkgm A: onAck(assetTransfer(X, …), marketMakerFilledAck)
    end
`}/>

:::tip

A user can split a big order over multiple packets to have a partial-filling like behavior.
For instance, one could split a \$100K order over 10 packets to allow different participants (usually market makers) to fill chunks of \$10K.

Read more on filling [here](/concepts/filling).

:::

:::warn

If any of the order in the `orders` list is failing on execution, the whole packet is reverted and a failure acknowledgement will be yield.

:::
